
** 跳表
跳表使用空间换时间的设计思路，通过构建多级索引来提高查询效率，实现了基于链表的“二分查找”。
跳表是动态数据结构
支持：插入、删除、查找、区间查找（找到区间起点，向后遍历即可，优于红黑树）：时间复杂度 O(log(n))
空间复杂度：O(n)，具体还要看多少个元素构建一个索引，如 2个为O(n), 3个为O(n/2)
实现：更新时采用随机函数，来决定将这个结点插入哪几级索引中，关键是采用怎样的随机函数
解决问题：如 Redis 的有序集合


** 散列表
散列表来源于数组，借助散列函数对数组进行扩展，利用其下标随机访问的特性。
核心问题：
  散列函数：简单，生成的值尽可能随机且均匀分布
  散列冲突：
    开放寻址法：线性探测，二次探测，双重探测
      适合数据量小，装载因子小（如0.75）
    链表法：每个位置对应一个链表（可改进为 红黑树、跳表等）
      适合数据量大，装载因子可大于1
支持：查询、插入、删除
解决问题：如word文档中单词纠错
工业级要求：
  支持快速的查询、插入、删除操作；
  内存占用合理，不能浪费过多的内存空间；
  性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。
设计思路：
  设计一个合适的散列函数；
  定义装载因子阈值，并且设计动态扩容策略；
  选择合适的散列冲突解决方法。
散列函数例子：
int hash(Object key) {
 int h = key.hashCode()；
 return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
}

--LRU缓存淘汰算法，LinkedHashMap
散列表+双向链表
