
** 跳表
跳表使用空间换时间的设计思路，通过构建多级索引来提高查询效率，实现了基于链表的“二分查找”。
跳表是动态数据结构
支持：插入、删除、查找、区间查找（找到区间起点，向后遍历即可，优于红黑树）：时间复杂度 O(log(n))
空间复杂度：O(n)，具体还要看多少个元素构建一个索引，如 2个为O(n), 3个为O(n/2)
实现：更新时采用随机函数，来决定将这个结点插入哪几级索引中，关键是采用怎样的随机函数
解决问题：如 Redis 的有序集合


** 散列表
散列表来源于数组，借助散列函数对数组进行扩展，利用其下标随机访问的特性。
核心问题：
  散列函数：简单，生成的值尽可能随机且均匀分布
  散列冲突（鸽巢原理）：
    开放寻址法：线性探测，二次探测，双重探测
      适合数据量小，装载因子小（如0.75）
    链表法：每个位置对应一个链表（可改进为 红黑树、跳表等）
      适合数据量大，装载因子可大于1
支持：查询、插入、删除
解决问题：如word文档中单词纠错
工业级要求：
  支持快速的查询、插入、删除操作；
  内存占用合理，不能浪费过多的内存空间；
  性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。
设计思路：
  设计一个合适的散列函数；
  定义装载因子阈值，并且设计动态扩容策略；
  选择合适的散列冲突解决方法。
散列函数例子：
int hash(Object key) {
 int h = key.hashCode()；
 return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
}

--LRU缓存淘汰算法，LinkedHashMap
散列表+双向链表

**哈希算法
应用：
  安全加密：如MD5、SHA、hash + salt
  唯一标识：对大数据做信息摘要，通过一个较短的二进制编码表示很大的数据
  数据校验：用于校验数据的完整性和正确性
  散列函数：对散列后的平均性和执行效率更看重
  负载均衡：通过哈希算法，对客户端IP或会话ID计算哈希值，再与服务器列表的大小取模，得到的值便是应该被路由到的服务器编号
  数据分片：
    统计“搜索关键词”出现次数？对数据进行分片，采用多台机器处理（原理同上），MapReduce
    快速判断图片是否在图库中？原理同上
  分布式存储：原理同上；一致性哈希算法：可解决缓存等分布式系统扩容、缩容导致数据大量搬移的难题
  还有许多，如网络协议中的CRC校验、Git commid id等等
  
**散列表 vs 平衡的二叉查找树
散列表：插入、删除、查找的时间复杂度可达到 O(1)
平衡的二叉查找树：插入、删除、查找时间复杂度为 O(log(n))
优缺点：
  散列表中数据是无序存储的，如果要输出有序的数据，则要先排序
  散列表扩容耗时多，当遇到散列冲突时，性能不稳定
  尽管散列表查找等操作时间复杂度是常量级，但由于有哈希冲突，不一定比 log(n) 小
  散列表的构造比二叉查找树更复杂，还要考虑散列函数的设计、冲突解决方法、扩容、缩容等
因此，各有优缺点，结合具体需求来选择
  
  
